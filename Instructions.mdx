## VOX: Voice Agent Builder — Instructions

### A Voice For Every Business

<Callout title="Introduction">
  This guide helps you create a custom voice agent for your business. Voice agents act as intelligent concierges, sales reps, or assistants—handling queries, accessing data, and performing actions like bookings or product searches. You'll define tools, connect to your data via APIs, and craft prompts to guide the agent's behavior.
</Callout>

**Assumptions**:
- Core tools (e.g., time checks, website scraping) are auto-provided by the platform.
- Use the JSON Editor tool to create/edit tool descriptors and prompts.
- Use the MongoDB Updater tool to store configurations in your tenant's database.
- Test directly by starting the agent or using provided test scripts.

<StepCard title="Understand Core Tools" description="These utility tools are available to every agent. Use them to enhance interactions without custom setup. Review the table below to see how they fit your use case.">
  Core tools are pre-defined and fed into the agent's schema automatically. They handle common tasks like fetching time, scraping websites, or rendering visuals. You don't need to define them, but reference them in your prompt for the agent to use them.

  **Tip**: The `scrapeWebsite` tool is powerful for dynamic data—e.g., a sales agent scraping recent product announcements from your site. For visuals, use `show_component` to display media fetched from your APIs.

  To integrate: Reference these in your prompt's "capabilities.tools" section (see Step 4).
</StepCard>

<StepCard title="Core Tools" description="Quick reference for built-in utilities.">
  Use these without extra setup. For visuals, prefer `show_component`.
</StepCard>

| Tool Name             | Description                                                                 | When to Use (Examples)                                                                 | Parameters |
|-----------------------|-----------------------------------------------------------------------------|----------------------------------------------------------------------------------------|------------|
| getCurrentTime        | Returns the current local time and timezone.                                | User asks "What time is it?" or needs time-based info.                                | None       |
| changeBackgroundColor | Toggles between light and dark UI themes.                                   | User says "Switch to dark mode" for accessibility or fun.                             | None       |
| partyMode             | Triggers confetti and animations for celebration.                           | User says "Celebrate!" after a successful booking or purchase.                        | None       |
| launchWebsite         | Opens a URL in a new browser tab.                                           | User asks "Open example.com" or to view external resources.                           | `url` (string, http/https) |
| copyToClipboard       | Copies text to the user's clipboard.                                        | User needs to copy a code, ID, or confirmation.                                       | `text` (string) |
| scrapeWebsite         | Fetches and returns website content as markdown/HTML for summarization.     | User asks to summarize a public site, e.g., "Scrape data.gov and tell me what's new." | `url` (string, http/https) |
| show_component        | Renders UI components like images, videos, payments, or catalogs.           | Display visuals, e.g., product images or a payment form. Supported components: payment_form, quote_summary, catalog_results, reservation_confirmation, room, video, image_viewer, media_gallery. | `component_name` (required), `title`, `description`, `size` (sm/md/lg/xl), `url`, `media` (array of image/video objects), `props` (object) |

---

<StepCard title="Define Custom Tools" description="Build HTTP-based tools to connect the agent to your APIs and databases. These allow actions like querying inventory, creating bookings, or searching products.">
  Custom tools are defined as JSON descriptors using the HTTP Tool Schema. They specify API endpoints, parameters, and behaviors.
</StepCard>

1. **Open the JSON Editor**: Use the JSON Editor tool to create a new descriptor file (e.g., `my-tools.json`).

2. **Define the Schema**: Each tool follows this structure (based on Zod schema for validation):

```json
{
  "kind": "http_tool",
  "name": "your_tool_name",
  "description": "Brief tool purpose",
  "parameters": {
    "type": "object",
    "properties": {
      "param1": { "type": "string" }
    },
    "required": ["param1"]
  },
  "http": {
    "method": "GET|POST|PUT|PATCH|DELETE",
    "urlTemplate": "https://your-api.com/endpoint/&#123;&#123;param1&#125;&#125;",
    "headers": { "authorization": "Bearer &#123;&#123;secrets.api_key&#125;&#125;" },
    "jsonBodyTemplate": { "key": "&#123;&#123;param1&#125;&#125;" },
    "okField": "ok",
    "timeoutMs": 8000,
    "pruneEmpty": true
  },
  "ui": {
    "onSuccess": {
      "open": {
        "component_name": "catalog_results",
        "title": "Results",
        "props": { "items": "&#123;&#123;response.items&#125;&#125;" }
      }
    },
    "onError": { /* Similar structure */ }
  },
  "enabled": true,
  "priority": 5,
  "version": 1
}

```

  3. **Examples**:
     - **Booking a Room** (from Cypress Resort):
       ```json
       {
         "name": "booking_reserve",
         "description": "Create a reservation for a unit between dates.",
         "parameters": {
           "type": "object",
           "required": ["tenant_id", "unit_id", "check_in", "check_out", "guest"],
           "properties": {
             "tenant_id": { "type": "string" },
             "unit_id": { "type": "string" },
             "check_in": { "type": "string", "pattern": "^\\d{4}-\\d{2}-\\d{2}$" },
             "check_out": { "type": "string", "pattern": "^\\d{4}-\\d{2}-\\d{2}$" },
             "guest": { /* Object with name, email, etc. */ }
           }
         },
         "http": {
           "method": "POST",
           "urlTemplate": "https://your-booking-api.com/api/booking/&#123;&#123;tenant_id&#125;&#125;/reserve",
           "jsonBodyTemplate": { /* Map params to body */ }
         }
       }
       ```
     - **Searching Products** (Generalized for e-commerce):
       ```json
       {
         "name": "search_products",
         "description": "Search inventory for products matching a query.",
         "parameters": {
           "type": "object",
           "required": ["query"],
           "properties": {
             "query": { "type": "string" },
             "limit": { "type": "number", "default": 10 }
           }
         },
         "http": {
           "method": "GET",
           "urlTemplate": "https://your-store-api.com/products?q=&#123;&#123;query&#125;&#125;&limit=&#123;&#123;limit&#125;&#125;"
         },
         "ui": {
           "onSuccess": {
             "open": {
               "component_name": "catalog_results",
               "props": { "items": "&#123;&#123;response.products&#125;&#125;" }
             }
           }
         }
       }
       ```
     - **MongoDB Query** (for custom data fetches):
       ```json
       {
         "name": "list_things_via_gateway",
         "description": "Browse catalog items (e.g., products, events).",
         "parameters": {
           "type": "object",
           "required": ["tenant_id"],
           "properties": {
             "tenant_id": { "type": "string" },
             "type": { "type": "string" },
             "q": { "type": "string" }
           }
         },
         "http": {
           "method": "POST",
           "urlTemplate": "/api/mongo/gateway",
           "jsonBodyTemplate": { "op": "find", "filter": { /* Mongo query */ } }
         }
       }
       ```
 Validation of Data Against SchemaI validated the provided tool descriptors (the actions array) against the Zod schema (HttpToolDescriptorSchema). All 6 tools parse successfully without errors, meaning they are structurally consistent and compatible with the schema. Here's a summary:Key Compatibilities:All tools have required fields like kind: "http_tool", name, http.method, http.urlTemplate.
parameters match the permissive JSON Schema-ish structure (object with type, required, properties, etc.).
http configs are valid (methods are correct enums, timeouts are positive integers ≤120000, etc.).
ui sections (where present) match HttpUISchema: component_name is string, size is valid enum, props are JSON-like.
Optional fields like description, priority, version, enabled are handled correctly.
Nested structures (e.g., guest and payment in booking_reserve) validate per their schemas (types, patterns, enums, min/max).

Minor Notes (Not Errors):Some tools use pattern in parameters (e.g., date regex), which is allowed as the schema is permissive.
jsonBodyTemplate can be complex objects with templates, which parses fine as JsonValue.
No invalid enums or types found.
The schema defaults kind to "http_tool" and enabled to true, which aligns with the data.

If you add new tools in the future, this schema will enforce consistency. The data represents a solid "standard" for well-formed descriptors.


  4. **Save and Upload**: Use the MongoDB Updater tool to store the descriptors under your tenantId (e.g., collection: "tools").

  **Tip**: Tools auto-populate the agent's decision-making. Ensure your APIs return structured JSON (e.g., `{ ok: true, data: {...} }`) for easy handling.

<StepCard title="Connect to Your Data" description="Expose data via APIs that tools can call. The agent uses returned objects to inform responses—e.g., describing products or checking availability.">
  Your APIs provide the "data grounding" for the agent. Design them to return rich JSON objects.

RATE LIMITS: Why both IP and user?

One user can abuse from many IPs (mobile, VPN, cloud).
One IP (office, campus, café) can have many legit users.
Combine both: block obvious floods at the IP layer (Edge), then apply precise user limits/quota (Server). This is the industry pattern (rate limit template + middleware).

1) Bot + Rate protections (technical)
Summary

This app defends the realtime LLM endpoint using layered protections:

Edge middleware — first line of defense at the edge (Vercel Edge / Next middleware). Fast IP + user limiting using Upstash or a dev in-memory fallback. Drops abusive traffic before it hits the API handler or DB.
BotID (client + server) — distinguishes automated clients vs human browsers. Client injects signals; server call (checkBotId()) evaluates them and can block suspicious bots.
Route-level rate limiter (withRateLimit) — server-side per-minute counters persisted in Mongo. Applies fixed-window counters and per-session tokens/dollars / daily quotas. It also clears session cookie if needed.
Session creation guards — concurrent-session caps (per-user), OTP authentication requirement (optional via .env toggle), and normalized tools validation.
In-session monitoring — client/server report of usage to /api/auth/usage, heartbeat endpoint for idle/duration enforcement, and session docs in Mongo to end sessions mid-stream when budget/duration exceeded.

These layers work together to:

Drop cheap/large-volume abusive traffic at the edge.
Block scripted bots with BotID.
Prevent single users from opening many realtime sessions.
Track tokens and estimated dollars in near real time and terminate sessions when daily caps are hit.

Full flow (step-by-step)

0. Client behaviour (what the app does)

Client loads <BotIdClient protect={[{path:'/api/session',method:'POST'}]} /> (or initBotId) in app/layout.tsx. BotID client collects signals and ensures the /api/session POST includes BotID headers.
When starting a voice session the client POST /api/session with e.g. { model, voice, tools, instructions }. If OTP mode is enabled the request must include tenant_session cookie (set by OTP flow).

1. Edge Middleware (middleware.ts) — first line

Matcher: /api/session (scoped).

What it enforces:

IP-based per-minute limiter (edge). Uses Upstash Ratelimit if configured; falls back to an in-memory per-minute counter in dev.
User-based per-minute limiter (edge) when the tenant_session cookie is present (uses email extracted from cookie).
If user limit is exceeded -> returns 429 and clears cookie (optional).
If IP limit is exceeded -> returns 429 (cookie may remain).

Why keep it: cheap rejects before route handler/DB work, lower latency for drops, prevents large distributed scans.

2. Route handler wrapper (withRateLimit) — server-side second line

Called from app/api/session/route.ts (the route POST is wrapped with withRateLimit(req, handler, cfg)).

What it does:

Obtains IP and session info via getActiveOtpSession() if cookie present.
Uses a Mongo-backed fixed-window counter (stored in ratelimits collection) to increment ip & user counters for the current minute window (upsert).
Checks per-minute thresholds (configurable). On exceeding, returns 429 and clears cookie.
Checks per-day quotas by reading the auth doc for the otp_session (usage tokens/dollars). If daily usage exceeds USER_MAX_TOKENS_DAILY / USER_MAX_DOLLARS_DAILY, mark session ended in DB, clear cookie, return 429.
Why keep it: this is authoritative server state (Mongo) — harder for an attacker to manipulate than client counters.

3. BotID server verdict (in createSession route)

Server call: const verdict = await checkBotId().
Decision: If verdict.isBot && !verdict.isVerifiedBot then reject 403. (You can tune policy to allow verified bots or blacklist certain bots.)

Why: prevents scripted automation that mimics browsers and bypasses simple checks.

4. OTP requirement (configurable)

Function used: getActiveOtpSession() (reads tenant_session cookie and looks up auth session in Mongo).
Policy toggle: set REQUIRE_AUTH_FOR_SESSION=true to force login before session creation.

If required: createSession rejects 401 if no active OTP session.

5. Concurrent session cap

Behavior: the realtime_sessions collection stores docs { _id: 's:${emailHash}:${opaqueId}', emailHash, startedAt, lastSeenAt, active }.
When creating a session, we countDocuments({ emailHash, active: true }) and reject with 429 if >= MAX_CONCURRENT_SESSIONS_PER_USER.
Why: stops one user from opening many simultaneous streams.

6. Upstream OpenAI realtime session creation

If checks pass, we call the OpenAI realtime sessions endpoint and return the upstream id plus our sm_session_id. We store a local session doc to enable heartbeats, idle checks, and mid-stream termination.

7. In-session usage reporting and enforcement

Client should report response.done usage events to /api/auth/usage with { tokens, dollars }. (Prefer server-side relay if tamper-proof needed.)
Server stores tokens/dollars in the auth doc (auth.usage.tokens, auth.usage.dollars) through app/api/auth/usage/route.ts.

Heartbeat endpoint: client pings /api/realtime/heartbeat periodically with { sm_session_id, email }. Server checks:
Session duration vs MAX_SESSION_MINUTES
Idle time vs MAX_SESSION_IDLE_SEC
Daily quota vs usage_daily doc

If any exceeded -> server sets realtime_sessions.active=false, clears cookie, returns 403 + reason -> client must close peer connection.

Why: allows mid-stream shutdown when a user keeps talking and hits budget or time limits.

Where token/dollar accounting originates

Best: use the Realtime API response.done events which include usage totals. Client forwards those to /api/auth/usage. Server increments auth.usage.
Reconciliation: optionally poll OpenAI Usage API periodically to reconcile for billing accuracy.

.env configuration (names, meanings, defaults)

Put these in .env — the app reads them to tune behavior.

RATE_IP_PER_MIN — integer. Max requests per IP per minute at the edge. Default: 60.
RATE_USER_PER_MIN — integer. Max requests per user per minute at the edge. Default: 120.
USER_MAX_TOKENS_DAILY — integer. Max tokens allowed per user per day before hard stop. Default: 150000.
USER_MAX_DOLLARS_DAILY — number. Max estimated dollars allowed per user per day. Default: 15.
MAX_CONCURRENT_SESSIONS_PER_USER — integer. Max live realtime sessions per user. Default: 2.
MAX_SESSION_MINUTES — integer. Max duration per session (minutes). Default: 15.
MAX_SESSION_IDLE_SEC — integer. Max idle time (seconds) allowed. Default: 90.

UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN — Upstash configuration for edge-limiter. If missing, middleware falls back to in-memory limiter (dev only).

REQUIRE_AUTH_FOR_SESSION — true|false. If true, /api/session requires an active OTP session cookie. Default: false (makes demo public but protected by BotID & rate-limits).

JWT_SECRET, TRANSPORT_*, OPENAI_API_KEY, DB envs — other envs used by routes.

How the system catches a protracted conversation (example timeline)

1. User opens session; client posts to /api/session:
2. Edge middleware checks IP & user minutely counters; allows or rejects.
3. Route-level withRateLimit increments Mongo counters and checks per-minute limits + daily quotas.
4. BotID server check validates client.
5. OTP check (if required) ensures identity.
6. Concurrent sessions check prevents many sessions.
6. Upstream session is created and local realtime_sessions doc added.
7. User interacts with the agent for many turns:
8. Client receives response.done events and posts usage (tokens/dollars) to /api/auth/usage. Server increments auth.usage.
9. Heartbeats from client update realtime_sessions.lastSeenAt.
10. When the user reaches daily tokens/dollars OR session duration/idle thresholds:
-- enforceDailyQuota() or heartbeat checks detect overage.
-- Server marks realtime_sessions.active=false, updates auth to status: 'ended', clears cookie, returns error to client.
-- Client receives error / close signal and closes the peer connection.

Because usage is tracked during the session and both minute- and daily-level quotas are enforced, a long protracted conversation will be caught either at the moment the /api/auth/usage increment pushes the auth doc beyond daily thresholds, or when heartbeat detects duration/idle violation.

Troubleshooting tips:

- If you see many 404/botid script errors: verify next.config.ts uses withBotId, client <BotIdClient /> is in layout, and you restarted dev server.
- If middleware returns 429 prematurely: check Upstash quotas & keys or change RATE_IP_PER_MIN/RATE_USER_PER_MIN.
- To debug per-user counters: inspect ratelimits (Mongo) and realtime_sessions collections.

For reconciliation of dollars: periodically poll OpenAI Usage API and reconcile with your auth.usage store.

</StepCard>

  1. **Build/Examine APIs**: Ensure endpoints match your tool descriptors. Use secure auth (e.g., Bearer tokens via secrets).

  2. **Data Object Structure**: Responses should be detailed but concise. Example for a hotel room (adapt for products/recipes/events):
     ```json
     {
       "name": "Ridge Villa",
       "unitNumber": "1",
       "type": "villa",
       "description": "Magnificent stream view with hot tub and sauna.",
       "rate": 685,
       "currency": "USD",
       "config": {
         "squareFeet": 825,
         "beds": [{ "size": "king", "count": 1 }],
         "amenities": { "wellness": ["hot tub", "sauna"] }
       },
       "images": [
         { "url": "https://example.com/image.jpg", "role": "gallery" }
       ],
       "policies": { "checkInTime": "15:00", "cancellation": { /* details */ } }
     }
     ```

     - For a product catalog: Include price, stock, images, reviews.
     - For recipes: Ingredients, steps, variations.

  3. **Test API Calls**: Use the JSON Editor to mock requests, or start the agent and query it to trigger tools.

  **Tip**: If data is in MongoDB, use gateway tools for direct queries. For web scraping, leverage core `scrapeWebsite`.


<StepCard title="Craft the System Prompt" description="The prompt activates the agent, sets its personality, and guides tool usage/dialog flow.">
  The prompt is a JSON object defining behavior, tool rules, and examples.
</StepCard>
  1. **Open the Prompt Editor**: Use the JSON Editor tool to create `agent-prompt.json`.

  2. **Structure**:
     ```json
     {
       "agent": {
         "tenantId": "your-business-id",
         "name": "Your Agent Name",
         "tone": "warm, concise, professional",
         "style_rules": [ /* Array of rules, e.g., "Always confirm details." */ ]
       },
       "capabilities": {
         "tools": {
           "your_custom_tool": {
             "when": [ /* Triggers, e.g., "User asks for availability." */ ],
             "args": [ /* Required params */ ],
             "success_say": "How to summarize results.",
             "handle_errors": { /* Error codes and responses */ }
           },
           // Include core tools as needed
           "scrapeWebsite": { /* ... */ }
         }
       },
       "policy": { /* Data rules, e.g., "Always check availability first." */ },
       "dialog_flow": { /* High-level steps */ },
       "schema_violation": [ /* Retry rules */ ],
       "response_templates": { /* Pre-formatted responses */ },
       "examples": [ /* User-agent interaction samples */ ]
     }
     ```

  3. **Example** (Adapted from Cypress for a product sales agent):
     ```json
     {
       "agent": {
         "name": "Product Guru",
         "tone": "helpful, enthusiastic",
         "style_rules": ["Never invent stock levels—call tools."]
       },
       "capabilities": {
         "tools": {
           "search_products": {
             "when": ["User asks about products or searches."],
             "args": ["query"],
             "success_say": "List top matches with prices and descriptions."
           },
           "show_component": {
             "when": ["Display product images."],
             "args": ["component_name", "media"]
           }
         }
       },
       "dialog_flow": {
         "high_level": ["Search products, show visuals, guide to purchase."]
       }
     }
     ```

  4. **Save and Activate**: Use MongoDB Updater to store under tenantId. Restart the agent to apply.

  **Tip**: Use examples to train flows, e.g., for a chef agent: Banter on ingredients by calling a recipe search tool.

<StepCard title="Test and Iterate" description="Verify the agent's accuracy, tool usage, and responses.">
  Focus on validating real-world questions and whether the agent calls tools with correct arguments and handles failures gracefully.
</StepCard>

### Test steps

1. **Start the Agent**: Launch via the platform dashboard or command line.
2. **Run Tests**:
   - Voice queries: “Book a room for Jan 15–18” (or your use case).
   - Check logs for tool calls and responses.
   - Use test scripts if available, or simulate via direct interaction.
3. **Debug**:
   - If tools fail: Check schemas and APIs.
   - Refine prompt for better flow.
   - Expand visuals registry as needed (platform will update based on demand).

**Tip**: Assume good intent; the agent handles edgy queries factually. Expand core tools/visuals via feedback.

---

### Data Model (abridged)

#### Tool Descriptor Model
Overview of the fields commonly used when defining a tool descriptor.

- `name`: Unique identifier  
- `parameters`: JSON Schema for args  
- `http`: Config for API call  
- `ui`: Auto-render visuals on outcomes  

#### Prompt Model
The structure that sets personality, constraints, and how tools should be chosen.

- `agent`: Personality and rules  
- `capabilities.tools`: Per-tool guidelines  
- `dialog_flow`: Conversation structure  

#### Data Object Model
The flexible JSON returned by your APIs that the agent uses for grounding.

- Flexible JSON from your APIs (e.g., products with name, price, images)  
- Used for grounding responses
